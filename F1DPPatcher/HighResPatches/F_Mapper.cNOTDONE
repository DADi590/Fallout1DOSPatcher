/*
The MIT License (MIT)
Copyright © 2022 Matt Wells

Permission is hereby granted, free of charge, to any person obtaining a copy of this
software and associated documentation files (the “Software”), to deal in the
Software without restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
and to permit persons to whom the Software is furnished to do so, subject to the
following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
//
// Original code modified by me, DADi590, to adapt it to this project, starting on 2022-08-28.

#include "../CLibs/stdio.h"
#include "../CLibs/stdlib.h"
#include "../CLibs/string.h"
#include "../GameAddrs/FalloutEngine.h"
#include "../Utils/BlockAddrUtils.h"
#include "../Utils/EXEPatchUtils.h"
#include "../Utils/GlobalEXEAddrs.h"
#include "../Utils/IniUtils.h"
#include "F_Mapper.h"
#include "F_Objects.h"
#include "HighResPatches.h"




struct bitset {
	uint32_t numBits;
	uint32_t *dwords;
	uint32_t numDwords;
};

void bitset(struct bitset *bit_set, uint32_t nBits) {
	bit_set->numBits=nBits;
	bit_set->numDwords = ((bit_set->numBits >> 5) + 1);
	bit_set->dwords = (uint32_t*)malloc(sizeof(uint32_t) * bit_set->numDwords);
	memset(bit_set->dwords, 0x0, sizeof(uint32_t) * bit_set->numDwords);
}
void unbitset(struct bitset *bit_set) {
	free(bit_set->dwords);
	bit_set->dwords = NULL;
}

void set1(struct bitset *bit_set, uint32_t bit) {
	uint32_t bindex = bit >> 5;
	uint32_t boffset= bit&0x1F;
	if(bindex < bit_set->numDwords)
		bit_set->dwords[bindex] |= (1 << boffset);
}
void set(struct bitset *bit_set) {
	memset(bit_set->dwords,0xFF, sizeof(uint32_t) * bit_set->numDwords);
}
void clear1(struct bitset *bit_set, uint32_t bit) {
	uint32_t bindex = bit >> 5;
	uint32_t boffset= bit&0x1F;
	if(bindex < bit_set->numDwords)
		bit_set->dwords[bindex] &= ~(1 << boffset);
}
void clear(struct bitset *bit_set) {
	memset(bit_set->dwords,0x00, sizeof(uint32_t) * bit_set->numDwords);
}
uint32_t get(struct bitset *bit_set, uint32_t bit) {
	uint32_t bindex = bit >> 5;
	uint32_t boffset= bit&0x1F;
	if(bindex < bit_set->numDwords)
		return bit_set->dwords[bindex] & (1 << boffset);
	else
		return 0;
}




int FOG_OF_WAR = false;
int32_t fogLight = 0x1000;
struct bitset *fogHexMapBits = NULL;

int32_t *pMAP_LEVEL = NULL;

int32_t *pNUM_HEX_X = NULL;
int32_t *pNUM_HEX_Y = NULL;
int32_t *pNUM_HEXES = NULL;

int32_t *pLightHexArray = NULL;

struct OBJStruct** lpObj_PC = NULL;

//____________________________________
bool CheckHexTransparency(int32_t hexNum) {
	if (hexNum < 0 || hexNum >= *pNUM_HEXES)
		return true;

	uint32_t flags = FLG_LightThru | FLG_ShootThru | FLG_TransNone;//|FLG_Flat;

	struct OBJNode* objNode = 0;
	int32_t objType = 0;

	objNode = pMapObjNodeArray[hexNum];
	objType = 0;

	if (fogHexMapBits && !fogHexMapBits->get(*pMAP_LEVEL * *pNUM_HEXES + hexNum))
		fogHexMapBits->set(*pMAP_LEVEL * *pNUM_HEXES + hexNum);

	while (objNode) {
		if (objNode->obj->level <= *pMAP_LEVEL) {
			if (objNode->obj->level == *pMAP_LEVEL) {
				objType = (objNode->obj->frmID & 0x0F000000) >> 0x18;

				if (objType == ART_WALLS && !(objNode->obj->flags & flags) || objType == ART_SCENERY && !(objNode->obj->flags & flags))// && !(objNode->obj->flags & OBJFLAG_TransNone) && !(objNode->obj->flags & OBJFLAG_Flat))
					return true;
			}
			objNode = objNode->next;
		}
		else
			objNode = NULL;
	}

	return false;
}

//step adjustment array ori 0-5 {evenHex y, oddHex y, x}
int32_t hexStep[6][3] = {
		{0,-1, -1}, {1, 0,-1},  {1, 1, 0},  {1, 0, 1},  {0,-1, 1}, {-1,-1,0}
};
int32_t hexStep2[6][3] = {
		{0,-200, -1}, {200, 0,-1},  {200, 200, 0},  {200, 0, 1},  {0,-200, 1}, {-200,-200,0}
};

//____________________________________________________________
int32_t GetNextHexPos(int32_t hexPos, uint32_t direction, int32_t distance) {
	//if(hexPos<=0 || hexPos>40000) return hexPos;

	int32_t xMax = *pNUM_HEX_X;
	int32_t yMax = *pNUM_HEX_Y;
	int32_t y = hexPos / xMax;
	int32_t x = hexPos % xMax;
	int32_t hexNew = hexPos;
	while (distance > 0) {

		y += ((int32_t **)getRealBlockAddrData(hexStep))[direction][(x & 0x01)];
		hexNew += ((int32_t **)getRealBlockAddrData(hexStep2))[direction][(x & 0x01)];
		x += ((int32_t **)getRealBlockAddrData(hexStep))[direction][2];
		hexNew += ((int32_t **)getRealBlockAddrData(hexStep2))[direction][2];

		if (x < 0 || x >= xMax)
			return hexPos;
		if (y < 0 || y >= yMax)
			return hexPos;

		hexPos = hexNew;

		distance--;
	}
	return hexPos;
}

//__________________________________________________
void GetHexSqrXY(int32_t hexPos, int32_t* px, int32_t* py) {
	//grid 1x =16pixels, 1y =12pixels
	//x must be divided by 2 to get hex width of 32pixels
	int32_t xMax = *pNUM_HEX_X;
	int32_t y = hexPos / xMax;
	int32_t x = hexPos % xMax;

	*py = y + (x >> 1);
	*px = (x << 1) - *py;

}

//__________________________________________
bool GetHexXY(int32_t hexPos, int32_t* x, int32_t* y) {
	if (hexPos < 0 || hexPos >= *pNUM_HEXES)
		return false;

	*y = hexPos / *pNUM_HEX_X;
	*x = hexPos % *pNUM_HEX_X;

	return true;
}

//_____________________________________________________
bool IsInLineOfSightBlocked(int32_t hexStart, int32_t hexEnd) {

	int32_t hexCurrent = hexStart;
	int32_t ori = 0;

	int32_t hexStartX = 0, hexStartY = 0;
	GetHexXY(hexStart, &hexStartX, &hexStartY);
	int32_t hexEndX = 0, hexEndY = 0;
	GetHexXY(hexEnd, &hexEndX, &hexEndY);
	int32_t hexCurrentX = 0, hexCurrentY = 0;
	GetHexXY(hexCurrent, &hexCurrentX, &hexCurrentY);

	int32_t squStartX = 0, squStartY = 0;
	GetHexSqrXY(hexStart, &squStartX, &squStartY);
	int32_t squEndX = 0, squEndY = 0;
	GetHexSqrXY(hexEnd, &squEndX, &squEndY);
	int32_t squCurrentX = 0, squCurrentY = 0;
	GetHexSqrXY(hexCurrent, &squCurrentX, &squCurrentY);

	int32_t hexesW = *pNUM_HEX_X;

	if (hexCurrentX == hexEndX) {//hex grid up and down (diagonal right/down to left/up)
		while (hexCurrent != hexEnd) {
			if (hexCurrentY < hexEndY)
				hexCurrent += hexesW;
			else
				hexCurrent -= hexesW;
			if (CheckHexTransparency(hexCurrent))
				return true;
		}
	}
	else if (hexCurrentY == hexEndY) {//hex grid left and right
		while (hexCurrent != hexEnd) {
			if (hexCurrentX < hexEndX)
				hexCurrent += 1;
			else
				hexCurrent -= 1;
			if (CheckHexTransparency(hexCurrent))
				return true;
		}
	}
	else if (squCurrentY == squEndY) {//square left and right
		while (hexCurrent != hexEnd) {
			if (squCurrentX > squEndX) {
				if (hexCurrent & 0x1)
					hexCurrent -= 1;
				else
					hexCurrent += hexesW - 1;
			}
			else {
				if (hexCurrent & 0x1)
					hexCurrent -= hexesW - 1;
				else
					hexCurrent += 1;
			}
			if (CheckHexTransparency(hexCurrent))
				return true;
		}

	}
	else if (squCurrentX == squEndX) {//square up and down
		while (hexCurrent != hexEnd) {
			if (squCurrentY < squEndY) {
				if (hexCurrent & 0x1) {
					if (CheckHexTransparency(hexCurrent + hexesW) && CheckHexTransparency(hexCurrent + 1))
						return true;
					hexCurrent += hexesW + 1;
				}
				else {
					if (CheckHexTransparency(hexCurrent + hexesW) && CheckHexTransparency(hexCurrent + hexesW + 1))
						return true;
					hexCurrent += hexesW + hexesW + 1;
				}
			}
			else {
				if (hexCurrent & 0x1) {
					if (CheckHexTransparency(hexCurrent - hexesW) && CheckHexTransparency(hexCurrent - hexesW - 1))
						return true;
					hexCurrent -= (hexesW + hexesW + 1);
				}
				else {
					if (CheckHexTransparency(hexCurrent - hexesW) && CheckHexTransparency(hexCurrent - 1))
						return true;
					hexCurrent -= (hexesW + 1);
				}
			}
			if (CheckHexTransparency(hexCurrent))
				return true;
		}
	}

	else if ((squEndY - squCurrentY) - (squEndX - squCurrentX) == 0) {//diagonal left/down to right/up
		while (hexCurrent != hexEnd) {
			if (squCurrentX < squEndX) {
				if (hexCurrent & 0x1)
					hexCurrent += 1;
				else
					hexCurrent += hexesW + 1;
			}
			else {
				if (hexCurrent & 0x1)
					hexCurrent -= (hexesW + 1);
				else
					hexCurrent -= 1;
			}
			if (CheckHexTransparency(hexCurrent))
				return true;
		}
	}
	else {
		int32_t distY = abs(squEndY - squCurrentY);
		int32_t distX = abs(squEndX - squCurrentX);
		int32_t distY2 = 0;//distY*distY;
		int32_t distX2 = 0;//distX*distY;
		int32_t error = 0;

		if (distY <= distX) {
			distY2 = distY * distY;
			distX2 = distX * distY;
			int32_t xPos = 0;
			if (squCurrentY < squEndY && squCurrentX < squEndX) {//square left/down shallow
				bool stepX = true;
				error = distX2 - distY2;
				while (hexCurrent != hexEnd) {
					if (error <= distX2) {
						if (CheckHexTransparency(hexCurrent))
							return true;
					}

					if (error > distX2) {
						error -= distX2;
						if (stepX) {
							if (hexCurrent & 0x1)
								hexCurrent += 1;
							else
								hexCurrent += (hexesW + 1);
							stepX = false;
						}
						else {
							hexCurrent += hexesW;
							stepX = true;
						}
					}
					else {
						if (stepX) {
							if (hexCurrent & 0x1)
								hexCurrent -= (hexesW - 1);
							else
								hexCurrent += 1;
							stepX = false;
						}
						else
							stepX = true;

						error += distY2;
					}
				}
			}
			else if (squCurrentY < squEndY && squCurrentX > squEndX) {//square right/down shallow
				bool stepX = false;
				error = distX2 - distY2;
				while (hexCurrent != hexEnd) {
					if (error <= distX2) {
						if (CheckHexTransparency(hexCurrent))
							return true;
					}
					if (error > distX2) {
						error -= distX2;
						if (!stepX) {
							hexCurrent += hexesW;
							stepX = true;
						}
						else {
							if (hexCurrent & 0x1)
								hexCurrent += 1;
							else
								hexCurrent += (hexesW + 1);
							stepX = false;
						}
					}
					else {
						if (!stepX) {
							if (hexCurrent & 0x1)
								hexCurrent -= 1;
							else
								hexCurrent += (hexesW - 1);
							stepX = true;
						}
						else
							stepX = false;
						error += distY2;
					}
				}
			}
			else if (squCurrentY > squEndY && squCurrentX < squEndX) {//square left/up shallow
				bool stepX = true;
				error = distX2 - distY2;
				while (hexCurrent != hexEnd) {
					if (CheckHexTransparency(hexCurrent))
						return true;

					if (error > distX2) {
						error -= distX2;
						if (stepX) {
							hexCurrent -= hexesW;
							stepX = false;
						}
						else {
							if (hexCurrent & 0x1)
								hexCurrent -= (hexesW + 1);
							else
								hexCurrent -= 1;
							stepX = true;
						}
					}
					else {
						if (stepX) {
							if (hexCurrent & 0x1)
								hexCurrent -= (hexesW - 1);
							else
								hexCurrent += 1;
							stepX = false;
						}
						else
							stepX = true;

						error += distY2;
					}
				}
			}
			else if (squCurrentY > squEndY && squCurrentX > squEndX) {//square right/up shallow
				bool stepX = false;
				error = distX2 - distY2;
				while (hexCurrent != hexEnd) {
					if (CheckHexTransparency(hexCurrent))
						return true;

					if (error > distX2) {
						error -= distX2;
						if (!stepX) {
							if (hexCurrent & 0x1)
								hexCurrent -= (hexesW + 1);
							else
								hexCurrent -= 1;
							stepX = true;
						}
						else {
							hexCurrent -= hexesW;
							stepX = false;
						}
					}
					else {
						if (!stepX) {
							if (hexCurrent & 0x1)
								hexCurrent -= 1;
							else
								hexCurrent += (hexesW - 1);
							stepX = true;
						}
						else
							stepX = false;
						error += distY2;
					}
				}
			}
			else
				return true;
		}
		else if (distY > distX) {
			distY2 = distY * distX;
			distX2 = distX * distX;
			if (squCurrentY < squEndY && squCurrentX < squEndX) {//square left/down steep
				bool stepX = true;
				error = distY2 - distX2;
				while (hexCurrent != hexEnd) {
					if (CheckHexTransparency(hexCurrent))
						return true;

					if (error > distY2) {
						error -= distY2;
						if (stepX) {
							if (hexCurrent & 0x1)
								hexCurrent -= (hexesW - 1);
							else
								hexCurrent += 1;
							stepX = false;
						}
						else
							stepX = true;
					}
					else {
						if (stepX) {
							if (hexCurrent & 0x1)
								hexCurrent += 1;
							else
								hexCurrent += (hexesW + 1);
							stepX = false;
						}
						else {
							hexCurrent += hexesW;
							stepX = true;
						}
						error += distX2;
					}
				}
			}
			else if (squCurrentY < squEndY && squCurrentX > squEndX) {//square right/down steep
				bool stepX = false;
				error = distY2 - distX2;
				while (hexCurrent != hexEnd) {
					if (CheckHexTransparency(hexCurrent))
						return true;

					if (error > distY2) {
						error -= distY2;
						if (!stepX) {
							if (hexCurrent & 0x1)
								hexCurrent -= 1;
							else
								hexCurrent += (hexesW - 1);
							stepX = true;
						}
						else
							stepX = false;
					}
					else {
						if (stepX) {
							if (hexCurrent & 0x1)
								hexCurrent += 1;
							else
								hexCurrent += (hexesW + 1);
							stepX = false;
						}
						else {
							hexCurrent += hexesW;
							stepX = true;
						}
						error += distX2;
					}
				}
			}
			else if (squCurrentY > squEndY && squCurrentX > squEndX) {//square right/up steep
				bool stepX = false;
				error = distY2 - distX2;
				while (hexCurrent != hexEnd) {
					if (CheckHexTransparency(hexCurrent))
						return true;

					if (error > distY2) {
						error -= distY2;
						if (!stepX) {
							if (hexCurrent & 0x1)
								hexCurrent -= 1;
							else
								hexCurrent += (hexesW - 1);
							stepX = true;
						}
						else
							stepX = false;
					}
					else {
						if (stepX) {
							hexCurrent -= hexesW;
							stepX = false;
						}
						else {
							if (hexCurrent & 0x1)
								hexCurrent -= (hexesW + 1);
							else
								hexCurrent -= 1;
							stepX = true;
						}
						error += distX2;
					}
				}
			}
			else if (squCurrentY > squEndY && squCurrentX < squEndX) {//square left/up steep
				bool stepX = true;
				error = distY2 - distX2;
				while (hexCurrent != hexEnd) {
					if (CheckHexTransparency(hexCurrent))
						return true;

					if (error > distY2) {
						error -= distY2;
						if (stepX) {
							if (hexCurrent & 0x1)
								hexCurrent -= (hexesW - 1);
							else
								hexCurrent += 1;
							stepX = false;
						}
						else
							stepX = true;
					}
					else {
						if (stepX) {
							hexCurrent -= hexesW;
							stepX = false;
						}
						else {
							if (hexCurrent & 0x1)
								hexCurrent -= (hexesW + 1);
							else
								hexCurrent -= 1;
							stepX = true;
						}
						error += distX2;
					}
				}
			}
			else
				return true;
		}
		else
			return true;
	}
	return false;
}

//_____________________________________________________________
int32_t GetFloorHexLight(int32_t elev, int32_t hexNum, int32_t globalLight) {
	if ((elev < 0) || (elev >= 3)) {
		return 0;
	}
	if ((hexNum < 0) || (hexNum >= *pNUM_HEXES)) {
		return 0;
	}

	int32_t elevOffset = elev * *pNUM_HEXES;
	int32_t light = pLightHexArray[elevOffset + hexNum];
	if (light < globalLight)
		light = globalLight;

	if (FOG_OF_WAR && light > fogLight && fogLight != 0) {
		struct OBJStruct* pObj_PC = *lpObj_PC;
		if (lpObj_PC && pObj_PC->hexNum != -1 && fogHexMapBits) {
			if (get(fogHexMapBits, elevOffset + hexNum) == 0 && IsInLineOfSightBlocked(pObj_PC->hexNum, hexNum))
				return fogLight;
		}
	}

	if (light > 0x10000)
		return 0x10000;
	else
		return light;
}


//__________________
void SetMapGlobals(void) {
	int temp_int = 0;
	char prop_value[MAX_PROP_VALUE_LEN];
	memset(prop_value, 0, MAX_PROP_VALUE_LEN);

	getPropValueIni(MAIN_INI_SPEC_SEC_HIGHRES_PATCH, "MAPS", "FOG_OF_WAR", "0", prop_value, &high_res_patch_ini_info_G);
	sscanf(prop_value, "%d", &temp_int);
	*(int *) getRealBlockAddrData(&FOG_OF_WAR) = (0 != temp_int);

	getPropValueIni(MAIN_INI_SPEC_SEC_HIGHRES_PATCH, "MAPS", "FOG_LIGHT_LEVEL", "0", prop_value, &high_res_patch_ini_info_G);
	sscanf(prop_value, "%d", &temp_int);
	if ((temp_int < 1) || (temp_int > 10)) {
		*(int32_t *) getRealBlockAddrData(&fogLight) = 0;
	} else {
		*(int32_t *) getRealBlockAddrData(&fogLight) = temp_int * 0x1000;
	}
}

void FMapperSetup(void) {
	pLightHexArray = getRealEXEAddr(D__tile_intensity);

	pMAP_LEVEL = getRealEXEAddr(D__map_elevation);

	pNUM_HEX_X = getRealEXEAddr(D__grid_width);
	pNUM_HEX_Y = getRealEXEAddr(D__grid_length);
	pNUM_HEXES = getRealEXEAddr(D__grid_size);

	lpObj_PC = getRealEXEAddr(D__obj_dude);
}
